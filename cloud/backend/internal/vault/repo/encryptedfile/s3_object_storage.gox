// cloud/backend/internal/vault/repo/encryptedfile/s3_object_storage.go
package encryptedfile

import (
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"path/filepath"
	"time"

	"go.uber.org/zap"

	"github.com/Maple-Open-Tech/monorepo/cloud/backend/config"
	"github.com/Maple-Open-Tech/monorepo/cloud/backend/pkg/storage/object/s3"
)

// s3ObjectStorage handles encrypted file content storage using S3
type s3ObjectStorage struct {
	logger     *zap.Logger
	s3Provider s3.S3ObjectStorage
	bucketName string
	folderPath string
}

// NewS3ObjectStorage creates a new S3-based object storage for encrypted files
func NewS3ObjectStorage(
	cfg *config.Configuration,
	logger *zap.Logger,
	s3Provider s3.S3ObjectStorage,
) *s3ObjectStorage {
	return &s3ObjectStorage{
		logger:     logger.With(zap.String("component", "s3-encrypted-file-storage")),
		s3Provider: s3Provider,
		bucketName: cfg.AWS.BucketName,
		folderPath: "encrypted-files", // Base folder for all encrypted files
	}
}

// UploadFile uploads an encrypted file to S3
func (s *s3ObjectStorage) UploadFile(
	ctx context.Context,
	userID string,
	fileID string,
	content io.Reader,
) (string, error) {
	// Create a path with user ID and file ID to segregate user files
	// For true E2EE, the path structure should not leak information about the file
	objectKey := filepath.Join(s.folderPath, userID, fileID)

	// For file uploads that don't come from multipart forms
	if multipartFile, ok := content.(multipart.File); ok {
		err := s.s3Provider.UploadContentFromMulipartWithVisibility(
			ctx,
			objectKey,
			multipartFile,
			false, // Private file, not public
		)
		if err != nil {
			s.logger.Error("Failed to upload encrypted file",
				zap.String("objectKey", objectKey),
				zap.Error(err),
			)
			return "", fmt.Errorf("failed to upload encrypted file: %w", err)
		}
	} else {
		// Read all content for standard io.Reader
		data, err := io.ReadAll(content)
		if err != nil {
			s.logger.Error("Failed to read content for upload",
				zap.Error(err),
			)
			return "", fmt.Errorf("failed to read content for upload: %w", err)
		}

		err = s.s3Provider.UploadContentWithVisibility(
			ctx,
			objectKey,
			data,
			false, // Private file, not public
		)
		if err != nil {
			s.logger.Error("Failed to upload encrypted file",
				zap.String("objectKey", objectKey),
				zap.Error(err),
			)
			return "", fmt.Errorf("failed to upload encrypted file: %w", err)
		}
	}

	s.logger.Debug("Successfully uploaded encrypted file",
		zap.String("objectKey", objectKey),
	)

	return objectKey, nil
}

// DownloadFile downloads an encrypted file from S3
func (s *s3ObjectStorage) DownloadFile(
	ctx context.Context,
	storagePath string,
) (io.ReadCloser, error) {
	content, err := s.s3Provider.GetBinaryData(ctx, storagePath)
	if err != nil {
		s.logger.Error("Failed to download encrypted file",
			zap.String("storagePath", storagePath),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to download encrypted file: %w", err)
	}

	return content, nil
}

// DeleteFile deletes an encrypted file from S3
func (s *s3ObjectStorage) DeleteFile(
	ctx context.Context,
	storagePath string,
) error {
	err := s.s3Provider.DeleteByKeys(ctx, []string{storagePath})
	if err != nil {
		s.logger.Error("Failed to delete encrypted file",
			zap.String("storagePath", storagePath),
			zap.Error(err),
		)
		return fmt.Errorf("failed to delete encrypted file: %w", err)
	}

	s.logger.Debug("Successfully deleted encrypted file",
		zap.String("storagePath", storagePath),
	)

	return nil
}

// GetDownloadURL generates a presigned URL for direct download
func (s *s3ObjectStorage) GetDownloadURL(
	ctx context.Context,
	storagePath string,
	expiryDuration time.Duration,
) (string, error) {
	url, err := s.s3Provider.GetPresignedURL(ctx, storagePath, expiryDuration)
	if err != nil {
		s.logger.Error("Failed to generate download URL for encrypted file",
			zap.String("storagePath", storagePath),
			zap.Error(err),
		)
		return "", fmt.Errorf("failed to generate download URL: %w", err)
	}

	s.logger.Debug("Generated presigned URL for encrypted file",
		zap.String("storagePath", storagePath),
		zap.Duration("expiry", expiryDuration),
	)

	return url, nil
}
